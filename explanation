Main idea: Think of a group of friends. After a trip or dinner, some paid more, some paid less.
The goal is: "Who owes how much to whom?", such that everyone ends up even. We donâ€™t care about who paid where, just the net balances.

Example:

A: -5 â†’ paid less, owes â‚¹5
B: +25 â†’ paid more, should receive â‚¹25

We match payers with receivers one by one to settle debts.

ðŸ”· 1. Rounding Function
double roundTo(double value, int places) {
    if (places < 0)
        throw invalid_argument("Invalid number of decimal places");

    double factor = pow(10.0, places);
    return round(value * factor) / factor;
}
ðŸ§  Logic: Rounding matters in money-related projects.
If you want 2 decimal places: Multiply value by 100 (factor) -> Round it to nearest integer -> Then divide by 100 to get back decimal

ðŸ”Ž Why needed?
To avoid floating-point errors like: 0.10000000009.

ðŸ”· 2. getKeyFromValue
string getKeyFromValue(unordered_map<string, double>& details, double value) {
    for (const auto& pair : details) {
        if (pair.second == value)
            return pair.first;
    }
    return "";
}
ðŸ§  Logic:
Maps store keyâ€“value pairs like this:
{ "A": -5, "B": 25, "C": -20 }  This function scans every entry and returns the personâ€™s name (key) whose balance equals the provided value.

Used to find: Person with the highest credit, Person with the most debt

ðŸ”· 3. findPath() â€” Main Balancing Logic
void findPath(unordered_map<string, double>& details) {
Goal: Keep reducing debts until all balances are zero.

Step-by-Step Inside findPath
ðŸ“ a. Find the person who has to receive most (max) and pay most (min):

auto maxIt = max_element(...);
auto minIt = min_element(...);
Example: { "A": -5, "B": 25, "C": -20 }  Max = B (25.0)  Min = C (-20.0)

We now settle between B and C.

ðŸ“ b. Add their balances: double result = roundTo(maxValue + minValue, 1);
So:

ini
Copy
Edit
result = 25 + (-20) = 5
This means: B still has â‚¹5 to collect, C is fully settled

ðŸ“ c. Check who is now done
if (result >= 0.0)
Case 1 â€“ result â‰¥ 0 â†’ payer fully paid, receiver partially satisfied
Print:

C needs to pay B: 20.00
Update:

B â†’ 5.0
C â†’ 0.0
Case 2 â€“ result < 0 â†’ receiver fully satisfied, payer still owes more
Print:

C needs to pay B: 25.00
Update:

B â†’ 0.0
C â†’ -5.0
ðŸ“ d. Update the map and call recursively
findPath(details); Repeat the process with updated values: Find max/min again, Reduce debts, Eventually all values will become 0.

ðŸ”· 4. main() â€” Setting Up the Scenario
unordered_map<string, double> parm;

parm["A"] = -5.0;
parm["B"] = 25.0;
parm["C"] = -20.0;
parm["D"] = 25.0;
parm["E"] = -20.0;
parm["F"] = -5.0;

findPath(parm);
ðŸ§  Logic:
Weâ€™re giving each friendâ€™s net balance (what they owe or get).

A owes â‚¹5, B gets â‚¹25, C owes â‚¹20, D gets â‚¹25, E owes â‚¹20, F owes â‚¹5

Now the function matches them to settle.

ðŸ§¾ Sample Execution Walkthrough
Letâ€™s run through the logic:

Max = D: â‚¹25, Min = C: â‚¹-20
âž¤ C pays D â‚¹20 â†’ Now D = â‚¹5, C = â‚¹0

Max = B: â‚¹25, Min = E: â‚¹-20
âž¤ E pays B â‚¹20 â†’ Now B = â‚¹5, E = â‚¹0

Max = D: â‚¹5, Min = A: â‚¹-5
âž¤ A pays D â‚¹5 â†’ Both 0

Max = B: â‚¹5, Min = F: â‚¹-5
âž¤ F pays B â‚¹5 â†’ Both 0

ðŸŸ¢ All balances are now 0

ðŸ”š Final Output:
C needs to pay D: 20.00
E needs to pay B: 20.00
A needs to pay D: 5.00
F needs to pay B: 5.00
ðŸ’¡ Key Insights
Concept	Meaning
Positive balance:Person is owed money, Negative balance:Person owes money
Match max and min	Always reduce largest payer and receiver
Recursive calls	Continue until everyone is settled

